"""Prototype 3. Uses OCEAN staking, and DTs."""
import json
import os
import random
import sys

import brownie
from brownie.network import accounts as br_accounts
from enforce_typing import enforce_types
import pytest
from pytest import approx

from ocean_lib.example_config import get_config_dict
from ocean_lib.models.predictoor.datatoken3 import Datatoken3
from ocean_lib.ocean.ocean import Ocean
from ocean_lib.ocean.mint_fake_ocean import mint_fake_OCEAN
from ocean_lib.ocean.util import from_wei, to_wei
from ocean_lib.web3_internal.utils import connect_to_network

# must be the same file as generated by deploy.py
ADDRESS_FILE = "~/.ocean/ocean-contracts/artifacts/address.json"

chain = brownie.network.chain

S_PER_MIN = 60
S_PER_HOUR = 60 * 60

@enforce_types
def test_main():
    # ======================================================================
    # SETUP
    config, ocean, OCEAN, accts =_setup()
    [deployer, opf, predictoor1, predictoor2, trader, rando, DT_treasurer] \
        = accts

    # convenience functions
    OCEAN_bal = ConvClass(OCEAN).fromWei_balanceOf
    OCEAN_approved = ConvClass(OCEAN).fromWei_approved

    # ======================================================================
    # PARAMETERS
    s_per_block = 2 # depends on the chain
    s_per_epoch = 5 * S_PER_MIN
    s_per_subscription = 24 * S_PER_HOUR
    min_predns_for_payout = 10 # ideally, 100+
    stake_token = OCEAN
    
    n_DTs = 100.0 # num DTs for sale
    DT_price = 10.0 # denominated in OCEAN
    
    # ======================================================================
    # DEPLOY DATATOKEN & EXCHANGE CONTRACT
    data_nft = ocean.data_nft_factory.create({"from": opf}, "DN", "DN")
    DT = data_nft.create_datatoken({"from": opf}, "DT","DT", template_index=3)
    
    DT.do_setup(
        s_per_block, s_per_epoch, s_per_subscription, min_predns_for_payout,
        stake_token)
                    
    # Mixed sol+py can't have DT to hold OCEAN, so have a different account
    # - When we convert to Solidity, change to: DT_treasurer = DT
    DT.treasurer = DT_treasurer

    # post DTs for sale
    DT.mint(opf, to_wei(n_DTs), {"from": opf})
    DT.setup_exchange({"from": opf}, to_wei(DT_price))
    DT.approve(DT.exchange.address, to_wei(n_DTs), {"from": opf})

    # ======================================================================
    # TRADER BUYS SUBSCRIPTION TO AGG PREDVALS (do every 24h)

    # trader buys 1 DT with OCEAN
    OCEAN_needed = from_wei(DT.exchange.BT_needed(to_wei(1), consume_market_fee=0))

    OCEAN.approve(DT.exchange.address, to_wei(OCEAN_needed), {"from": trader})
    DT.exchange.buy_DT(to_wei(1), {"from": trader})  # spends OCEAN

    # trader starts subscription. Good for 24h.
    DT.approve(DT.address, to_wei(1), {"from": trader})
    DT.start_subscription({"from": trader})  # good for next 24h

    # ======================================================================
    # ======================================================================
    # LOOP across epochs
    n_epochs = DT.min_predns_for_payout + 3
    
    stake1 = 2.0  # Stake per prediction. In OCEAN
    stake2 = 1.0  # ""
    OCEAN.approve(DT_treasurer, to_wei(stake1*n_epochs), {"from": predictoor1})
    OCEAN.approve(DT_treasurer, to_wei(stake2*n_epochs), {"from": predictoor2})

    blocks_seen_by_trader = set()
    
    n_blocks = n_epochs * DT.blocks_per_epoch + 3
    final_blocknum = int(cur_blocknum() + n_blocks)

    while cur_blocknum() < final_blocknum:
        actions_s = ""

        # PREDICTOORS STAKE & SUBMIT PREDVALS (do every 5min)
        predict_blocknum = DT.soonest_block_to_predict()
        if not DT.submitted_predval(predict_blocknum, predictoor1.address):
            predval1 = random.choice([True, False])
            DT.submit_predval(
                predval1, stake1, predict_blocknum, {"from": predictoor1})
            actions_s += "Predictoor1 submitted a prediction\n"

        predict_blocknum = DT.soonest_block_to_predict() # in case changed!
        if not DT.submitted_predval(predict_blocknum, predictoor2.address):
            predval2 = random.choice([True, False])
            DT.submit_predval(
                predval2, stake2, predict_blocknum, {"from": predictoor2})
            actions_s += "Predictoor2 submitted a prediction\n"

        # TRADER GETS AGG PREDVAL (do every 5min)
        predict_blocknum = DT.soonest_block_to_predict() # in case changed!
        if predict_blocknum not in blocks_seen_by_trader:
            agg_predval = DT.get_agg_predval(predict_blocknum)
            assert 0.0 <= agg_predval <= 1.0
            blocks_seen_by_trader.add(predict_blocknum)
            actions_s += "Trader got an agg_predval\n"

        # OWNER SUBMITS TRUE VALUE. This will update predictoors' claimable amts
        for predict_blocknum in DT.predobjs:
            if predict_blocknum in DT.truevals: # already set 
                continue
            if cur_blocknum() < predict_blocknum: # not enough time passed
                continue
            trueval = random.choice([True, False])
            DT.submit_trueval(trueval, predict_blocknum, {"from": opf})
            chain.mine(1) # forced this, because prev step isn't on chain
            actions_s += "OPF submitted a trueval\n"

        # MAYBE MINE. LOG OUTPUT
        block_s = f"Done blocknum={cur_blocknum()}, epoch={DT.cur_epoch()}"
        if actions_s == "": # nothing happened, so move forward by a block
            chain.mine(1)
            if cur_blocknum() % 50 == 0:
                print(block_s)
            else:
                print(".", end="")
                sys.stdout.flush() #needed for the . to show up immediately
        else:
            print()
            print(f"=" * 30 + "\n" +
                  block_s + "\n" + 
                  actions_s)

    # ======================================================================
    # PREDICTOORS & OPF COLLECT SALES REVENUE

    # Any rando can call update_error_calcs()
    DT.update_error_calcs(predict_blocknum, {"from": rando})

    # Any rando can call get_payout(). Will update amt allowed
    DT.get_payout(predict_blocknum, predictoor0.address, {"from": rando})
    DT.get_payout(predict_blocknum, predictoor1.address, {"from": rando})

    balDT = OCEAN_bal(DT_treasurer)
    bal1, bal2 = OCEAN_bal(predictoor1), OCEAN_bal(predictoor2)
    earned1, earned2 = (bal1 - initbal1), (bal2 - initbal2)
    earned = earned1 + earned2

    assert balDT == initbalDT - earned
    assert bal1 > initbal1
    assert bal2 > initbal2
    assert earned2 > earned1


def _setup():
    # ======================================================================
    # SETUP SYSTEM
    connect_to_network("development")

    # create base accounts
    deployer = br_accounts.add(os.getenv("FACTORY_DEPLOYER_PRIVATE_KEY"))
    opf = br_accounts.add(os.getenv("TEST_PRIVATE_KEY1"))

    # set ocean object
    address_file = os.path.expanduser(ADDRESS_FILE)
    print(f"Load contracts from address_file: {address_file}")
    config = get_config_dict("development")
    config["ADDRESS_FILE"] = address_file
    ocean = Ocean(config, "no_provider")

    # DEPLOYER mints 20K OCEAN, and sends 2K OCEAN to TEST_PRIVATE_KEY1 & 2
    mint_fake_OCEAN(config)

    # convenience objects
    OCEAN = ocean.OCEAN_token
    OCEAN_bal = ConvClass(OCEAN).fromWei_balanceOf

    # ======================================================================
    # SETUP USER ACCOUNTS
    # Ensure that users have OCEAN and ETH as needed
    # -Note: Barge minted fake OCEAN and gave it to TEST_PRIVATE_KEY{1,2}
    # -Note: we don't _need_ to have private keys 3-6. But doing it means
    #  we can give them ETH on launch rather than here, which is faster

    def _acct(key_i: int):
        return br_accounts.add(os.getenv(f"TEST_PRIVATE_KEY{key_i}"))

    predictoor1, predictoor2, trader, rando, DT_treasurer = (
        _acct(2),
        _acct(3),
        _acct(4),
        _acct(5),
        _acct(6),
    )

    accts = [deployer, opf, predictoor1, predictoor2, trader, rando, DT_treasurer]
    accts_needing_ETH = [opf, predictoor1, predictoor2, trader, rando, DT_treasurer]
    accts_needing_OCEAN = [opf, predictoor1, predictoor2, trader]

    print("\nBalances before moving funds:")
    for i, acct in enumerate(accts):
        print(f"acct {i}: {ETH_bal(acct)} ETH, {OCEAN_bal(acct)} OCEAN")

    print("\nMove ETH...")
    for acct in accts_needing_ETH:
        if ETH_bal(acct) == 0:
            deployer.transfer(acct, to_wei(1.0))

    print("\nMove OCEAN...")
    for acct in accts_needing_OCEAN:
        if OCEAN_bal(acct) <= 25.0:
            OCEAN.transfer(acct, to_wei(250.0), {"from": deployer})

    print("\nBalances after moving funds:")
    for i, acct in enumerate(accts):
        print(f"acct {i}: {ETH_bal(acct)} ETH, {OCEAN_bal(acct)} OCEAN")

    predictoors = [predictoor1, predictoor2]

    return config, ocean, OCEAN, accts

@enforce_types
class ConvClass:
    def __init__(self, token):
        self.token = token

    def fromWei_balanceOf(self, obj) -> float:
        return from_wei(self.token.balanceOf(obj.address))

    def fromWei_approved(self, obj1, obj2) -> float:
        return from_wei(self.token.allowance(obj1.address, obj2.address))

@enforce_types
def ETH_bal(acct) -> int:
    return from_wei(acct.balance())

@enforce_types
def cur_blocknum() -> int:
    return chain[-1].number
