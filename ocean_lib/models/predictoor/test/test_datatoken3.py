"""Prototype 3. Uses OCEAN staking, and DTs."""
import json
import os

import brownie
from brownie.network import accounts as br_accounts
import pytest
from pytest import approx

from ocean_lib.example_config import get_config_dict
from ocean_lib.web3_internal.utils import connect_to_network
from ocean_lib.ocean.ocean import Ocean
from ocean_lib.ocean.mint_fake_ocean import mint_fake_OCEAN
from ocean_lib.ocean.util import from_wei, to_wei

# must be the same file as generated by deploy.py
ADDRESS_FILE = "~/.ocean/ocean-contracts/artifacts/address.json"

chain = brownie.network.chain


@pytest.mark.unit
def test_exchange():  # HACK for getting exchange working
    connect_to_network("development")

    # create base accounts
    deployer = br_accounts.add(os.getenv("FACTORY_DEPLOYER_PRIVATE_KEY"))
    opf = br_accounts.add(os.getenv("TEST_PRIVATE_KEY1"))
    alice = br_accounts.add(os.getenv("TEST_PRIVATE_KEY2"))
    bob = br_accounts.add()

    # set ocean object
    address_file = os.path.expanduser(ADDRESS_FILE)
    print(f"Load contracts from address_file: {address_file}")
    config = get_config_dict("development")
    config["ADDRESS_FILE"] = address_file
    ocean = Ocean(config, "no_provider")  # is this the issue??

    # DEPLOYER mints 20K OCEAN, and sends 2K OCEAN to TEST_PRIVATE_KEY1 & 2
    mint_fake_OCEAN(config)

    #
    OCEAN = ocean.OCEAN_token

    data_nft = ocean.data_nft_factory.create({"from": alice}, "DNFT1", "DNFT1")

    DT = data_nft.create_datatoken(
        {"from": alice},
        template_index=1,
        cap=None,
        name="DT1",
        symbol="DT1Symbol",
        minter=alice.address,  # is this the issue?? I need this i think
    )

    exchange = DT.create_exchange(
        rate=to_wei(3),
        base_token_addr=OCEAN.address,
        tx_dict={"from": alice},
        with_mint=False,
    )


@pytest.mark.unit
def test_main_py():
    _test_main(use_py=True)


@pytest.mark.unit
@pytest.mark.skip(reason="turn this on once .sol version is built")
def test_main_sol():
    _test_main(use_py=False)


def _test_main(use_py):

    # ======
    # SETUP SYSTEM

    connect_to_network("development")

    # create base accounts
    deployer = br_accounts.add(os.getenv("FACTORY_DEPLOYER_PRIVATE_KEY"))
    opf = br_accounts.add(os.getenv("TEST_PRIVATE_KEY1"))

    # set ocean object
    address_file = os.path.expanduser(ADDRESS_FILE)
    print(f"Load contracts from address_file: {address_file}")
    config = get_config_dict("development")
    config["ADDRESS_FILE"] = address_file
    ocean = Ocean(config, "no_provider")

    # DEPLOYER mints 20K OCEAN, and sends 2K OCEAN to TEST_PRIVATE_KEY1 & 2
    mint_fake_OCEAN(config)

    # convenience objects
    OCEAN = ocean.OCEAN_token

    # convenience functions
    c = ConvClass(OCEAN)
    OCEAN_bal = c.fromWei_balanceOf
    OCEAN_approved = c.fromWei_approved

    def ETH_bal(acct):
        return from_wei(acct.balance())

    # ======================================================================
    # DEPLOY DATATOKEN & EXCHANGE CONTRACT

    min_blocks_ahead = 20  # Pred'ns must be >= this # blocks ahead
    min_predns_for_payout = 100  # Predictoor must have >= this # predn's to get paid
    num_blocks_subscription = 86400 / 10  # 1 day

    # can reuse existing DNFT template
    data_nft = ocean.data_nft_factory.create(
        {"from": opf},
        "Data NFT 1",
        "DNFT1",  # and any other DataNFTArguments
    )

    # new DT template with Predictoor functionality
    #  DataNFT.create_datatoken(tx_dict, *args, **kwargs)
    #   -> datatoken_args:DatatokenArguments = get_args_object(args, kwargs, DatatokenArguments)
    #     -> DatatokenArguments.__init__(..., min_blocks_ahead=__, ..)
    #       -> self.min_blocks_ahead = __
    #   -> datatoken_args:DatatokenArguments.create_datatoken(self, tx_dict)
    #     -> config_dict = data_nft.config_dict
    #     -> data_nft:DataNFT.contract.createERC20(template_index, [.], [.], ..)
    #     -> datatoken = DatatokenBase.get_typed(config_dict, new_elements[0])

    # params
    n_DTs = 100.0
    DT_price = 10.0  # denominated in OCEAN

    # HACK START
    DT0 = data_nft.create_datatoken(
        {"from": opf},
        name="DT0",
        symbol="DT0",
        template_index=1,
        # and any other DatatokenArguments
    )
    DT0.mint(opf, to_wei(n_DTs), {"from": opf})
    exchange = DT0.create_exchange({"from": opf}, to_wei(DT_price), OCEAN.address)
    # HACK END

    DT = data_nft.create_datatoken(
        {"from": opf},
        name="DT",
        symbol="DT",
        template_index=3,
        min_blocks_ahead=min_blocks_ahead,
        min_predns_for_payout=min_predns_for_payout,
        num_blocks_subscription=num_blocks_subscription,
        # and any other DatatokenArguments
    )
    assert DT.getId() == 3
    DT = DT.get_typed(config, DT.address)

    # post 100 DTs for sale
    DT.mint(opf, to_wei(n_DTs), {"from": opf})
    exchange = DT.create_exchange({"from": opf}, to_wei(DT_price), OCEAN.address)
    DT.approve(exchange.address, to_wei(n_DTs), {"from": opf})

    # ======================================================================
    # SETUP USER ACCOUNTS
    predictoor1 = br_accounts.add(os.getenv("TEST_PRIVATE_KEY2"))
    predictoor2 = br_accounts.add()
    trader = br_accounts.add()
    rando = br_accounts.add()
    accts = [deployer, opf, predictoor1, predictoor2, trader, rando]

    # Ensure that users have OCEAN and ETH as needed
    # -Note: Barge minted fake OCEAN and gave it to TEST_PRIVATE_KEY{1,2}

    print("n\Balances before moving funds:")
    for i, acct in enumerate(accts):
        print(f"acct {i}: {ETH_bal(acct)} ETH, {OCEAN_bal(acct)} OCEAN")

    print("\nMove funds...")
    for acct in [predictoor2, trader, rando]:
        deployer.transfer(acct, to_wei(1.0))
        OCEAN.transfer(acct, to_wei(10.0), {"from": deployer})

    print("\nBalances after moving funds:")
    for i, acct in enumerate(accts):
        print(f"acct {i}: {ETH_bal(acct)} ETH, {OCEAN_bal(acct)} OCEAN")

    # check if enough funds
    for i, acct in enumerate(accts):
        assert ETH_bal(acct) > 0, f"acct {i} needs ETH"
        assert OCEAN_bal(acct), f"acct {i} needs OCEAN"

    predictoors = [predictoor1, predictoor2]

    # ======================================================================
    # TRADER BUYS SUBSCRIPTION TO AGG PREDVALS (do every 24h)

    # trader buys 1 DT with OCEAN
    OCEAN_needed = exchange.BT_needed(to_wei(1), consume_market_fee=0)
    OCEAN.approve(exchange.address, to_wei(OCEAN_needed), {"from": trader})
    OCEAN.mint(trader, (OCEAN_needed), {"from": deployer})
    assert OCEAN.balanceOf(trader) >= OCEAN_needed
    exchange.buy_DT(to_wei(1), {"from": trader})  # spends OCEAN

    # trader starts subscription. Good for 24h.
    # -"start_subscription" is like pay_for_access_service, but w/o DDO
    DT.approve(DT.address, to_wei(1), {"from": trader})
    DT.start_subscription({"from": trader})  # good for next 24h (or 1h, 7d, ..)

    # ======================================================================
    # PREDICTOORS STAKE & SUBMIT PREDVALS (do every 5min)
    predval1, stake1 = 200, 10.0
    predval2, stake2 = 500, 20.0
    predict_blocknum = 100

    OCEAN.mint(predictoor1, to_wei(stake1), {"from": deployer})
    OCEAN.mint(predictoor2, to_wei(stake2), {"from": deployer})

    OCEAN.approve(DT.address, to_wei(stake1), {"from": predictoor1})
    OCEAN.approve(DT.address, to_wei(stake2), {"from": predictoor2})
    assert OCEAN_approved(predictoor1, DT) == stake1  # new, ready to use
    assert OCEAN_approved(predictoor2, DT) == stake2  # ""

    initbal1 = OCEAN_bal(predictoor1)
    initbal2 = OCEAN_bal(predictoor2)

    DT.submit_predval(
        OCEAN, to_wei(predval1), to_wei(stake1), predict_blocknum, {"from": predictoor1}
    )
    DT.submit_predval(
        OCEAN, to_wei(predval2), to_wei(stake2), predict_blocknum, {"from": predictoor2}
    )

    # test

    assert OCEAN_bal(DT) == (stake1 + stake2)  # just got new stake
    assert OCEAN_bal(predictoor1) == approx(initbal1 - stake1)  # just staked
    assert OCEAN_bal(predictoor2) == approx(initbal2 - stake2)  # ""
    assert OCEAN_approved(predictoor1, DT) == 0.0  # just used up
    assert OCEAN_approved(predictoor2, DT) == 0.0  # ""

    # ======================================================================
    # TRADER GETS AGG PREDVAL (do every 5min)

    # trader gets prediction itself
    # -a tx isn't needed, therefore Solidity can return a value directly
    # -"get_agg_predval" is like ocean.assets.download_asset //
    #  asset_downloader.download_asset_files() except there's no downloading,
    #  rather it simply gives the agg_predval. (To generalize: reveals secret)
    agg_predval_wei = DT.get_agg_predval(predict_blocknum)
    assert agg_predval_wei == to_wei(400.0)

    # ======================================================================
    # TIME PASSES - enough such that predict_blocknum has passed
    chain.mine(min_blocks_ahead + 10)  # pass enough time (blocks) so that  pass

    # ======================================================================
    # OWNER SUBMITS TRUE VALUE. This will update predictoors' claimable amts
    trueval = 449.0
    DT.submit_trueval(predict_blocknum, to_wei(trueval), {"from": opf})

    # ======================================================================
    # TIME PASSES - enough for predictoors to get claims

    # FIXME - we'll need to do 'min_predns_for_payout' loops through this
    #   step and and several prev steps, for predictoors to actually get paid
    print(int(1.2 * min_blocks_ahead * min_predns_for_payout))
    chain.mine(int(1.2 * min_blocks_ahead * min_predns_for_payout))

    # ======================================================================
    # PREDICTOORS & OPF COLLECT SALES REVENUE

    # Any rando can call release(). Will update amt allowed
    # OR!!! this is where exchange object comes in!!

    for acct in predictoors:
        balbefore = OCEAN_bal(acct)
        DT.get_payout(predict_blocknum, OCEAN, acct.address, {"from": rando})
        balafter = OCEAN_bal(acct)
        assert balafter > balbefore


class ConvClass:
    def __init__(self, token):
        self.token = token

    def fromWei_balanceOf(self, obj) -> float:
        return from_wei(self.token.balanceOf(obj.address))

    def fromWei_approved(self, obj1, obj2) -> float:
        return from_wei(self.token.allowance(obj1.address, obj2.address))


def _cur_blocknum():
    return chain[-1].number
